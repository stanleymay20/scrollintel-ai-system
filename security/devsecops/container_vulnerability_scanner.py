"""
Container Vulnerability Scanner with Misconfiguration Detection
Implements comprehensive container security scanning for DevSecOps pipeline
"""

import asyncio
import logging
import json
import subprocess
import tempfile
import os
from datetime import datetime
from typing import Dict, List, Optional, Any, Tuple
from enum import Enum
from dataclasses import dataclass
import docker
import yaml

logger = logging.getLogger(__name__)

class VulnerabilitySeverity(Enum):
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    NEGLIGIBLE = "negligible"

class MisconfigurationType(Enum):
    SECURITY = "security"
    PERFORMANCE = "performance"
    COMPLIANCE = "compliance"
    BEST_PRACTICE = "best_practice"

@dataclass
class Vulnerability:
    cve_id: str
    severity: VulnerabilitySeverity
    package: str
    version: str
    fixed_version: Optional[str]
    description: str
    cvss_score: float
    references: List[str]

@dataclass
class Misconfiguration:
    check_id: str
    type: MisconfigurationType
    severity: VulnerabilitySeverity
    title: str
    description: str
    remediation: str
    file_path: Optional[str] = None
    line_number: Optional[int] = None

@dataclass
class ScanResult:
    image_name: str
    image_tag: str
    scan_timestamp: datetime
    vulnerabilities: List[Vulnerability]
    misconfigurations: List[Misconfiguration]
    security_score: float
    compliance_score: float
    scan_duration: float
    metadata: Dict[str, Any]

class ContainerVulnerabilityScanner:
    """
    Comprehensive container vulnerability scanner with misconfiguration detection
    """
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.docker_client = docker.from_env()
        self.scan_tools = {
            "trivy": self._scan_with_trivy,
            "grype": self._scan_with_grype,
            "clair": self._scan_with_clair
        }
        self.misconfiguration_checks = self._load_misconfiguration_checks()
        
    def _load_misconfiguration_checks(self) -> Dict[str, Any]:
        """Load container misconfiguration checks"""
        return {
            "dockerfile_checks": [
                {
                    "id": "USER_ROOT",
                    "type": MisconfigurationType.SECURITY,
                    "severity": VulnerabilitySeverity.HIGH,
                    "title": "Container running as root",
                    "description": "Container is configured to run as root user",
                    "remediation": "Add USER directive to run as non-root user",
                    "pattern": r"^USER\s+root\s*$|^(?!.*USER)"
                },
                {
                    "id": "EXPOSED_SECRETS",
                    "type": MisconfigurationType.SECURITY,
                    "severity": VulnerabilitySeverity.CRITICAL,
                    "title": "Exposed secrets in environment",
                    "description": "Secrets found in environment variables",
                    "remediation": "Use secret management systems instead of environment variables",
                    "pattern": r"ENV\s+.*(?:PASSWORD|SECRET|KEY|TOKEN).*="
                },
                {
                    "id": "PRIVILEGED_MODE",
                    "type": MisconfigurationType.SECURITY,
                    "severity": VulnerabilitySeverity.CRITICAL,
                    "title": "Privileged mode enabled",
                    "description": "Container configured to run in privileged mode",
                    "remediation": "Remove --privileged flag and use specific capabilities",
                    "pattern": r"--privileged"
                },
                {
                    "id": "NO_HEALTHCHECK",
                    "type": MisconfigurationType.BEST_PRACTICE,
                    "severity": VulnerabilitySeverity.MEDIUM,
                    "title": "No health check defined",
                    "description": "Container has no health check configured",
                    "remediation": "Add HEALTHCHECK instruction to Dockerfile",
                    "pattern": r"^(?!.*HEALTHCHECK)"
                },
                {
                    "id": "LATEST_TAG",
                    "type": MisconfigurationType.BEST_PRACTICE,
                    "severity": VulnerabilitySeverity.MEDIUM,
                    "title": "Using latest tag",
                    "description": "Base image uses 'latest' tag",
                    "remediation": "Use specific version tags for base images",
                    "pattern": r"FROM\s+\S+:latest"
                }
            ],
            "runtime_checks": [
                {
                    "id": "WRITABLE_ROOT_FS",
                    "type": MisconfigurationType.SECURITY,
                    "severity": VulnerabilitySeverity.HIGH,
                    "title": "Writable root filesystem",
                    "description": "Container root filesystem is writable",
                    "remediation": "Use read-only root filesystem with --read-only flag"
                },
                {
                    "id": "EXCESSIVE_CAPABILITIES",
                    "type": MisconfigurationType.SECURITY,
                    "severity": VulnerabilitySeverity.HIGH,
                    "title": "Excessive capabilities",
                    "description": "Container has unnecessary Linux capabilities",
                    "remediation": "Drop all capabilities and add only required ones"
                },
                {
                    "id": "HOST_NETWORK",
                    "type": MisconfigurationType.SECURITY,
                    "severity": VulnerabilitySeverity.HIGH,
                    "title": "Host network mode",
                    "description": "Container using host network mode",
                    "remediation": "Use bridge or custom network instead of host network"
                }
            ]
        }
    
    async def scan_image(
        self, 
        image_name: str,
        image_tag: str = "latest",
        scan_options: Optional[Dict[str, Any]] = None
    ) -> ScanResult:
        """Scan container image for vulnerabilities and misconfigurations"""
        start_time = datetime.now()
        full_image_name = f"{image_name}:{image_tag}"
        
        logger.info(f"Starting container scan for {full_image_name}")
        
        try:
            # Pull image if not available locally
            await self._ensure_image_available(full_image_name)
            
            # Run vulnerability scans
            vulnerabilities = await self._scan_vulnerabilities(full_image_name, scan_options)
            
            # Run misconfiguration checks
            misconfigurations = await self._scan_misconfigurations(full_image_name)
            
            # Calculate security scores
            security_score = self._calculate_security_score(vulnerabilities, misconfigurations)
            compliance_score = self._calculate_compliance_score(misconfigurations)
            
            scan_duration = (datetime.now() - start_time).total_seconds()
            
            result = ScanResult(
                image_name=image_name,
                image_tag=image_tag,
                scan_timestamp=start_time,
                vulnerabilities=vulnerabilities,
                misconfigurations=misconfigurations,
                security_score=security_score,
                compliance_score=compliance_score,
                scan_duration=scan_duration,
                metadata={
                    "scan_tools_used": list(self.scan_tools.keys()),
                    "total_vulnerabilities": len(vulnerabilities),
                    "total_misconfigurations": len(misconfigurations),
                    "critical_vulnerabilities": len([v for v in vulnerabilities if v.severity == VulnerabilitySeverity.CRITICAL]),
                    "high_vulnerabilities": len([v for v in vulnerabilities if v.severity == VulnerabilitySeverity.HIGH])
                }
            )
            
            logger.info(f"Container scan completed for {full_image_name} in {scan_duration:.2f}s")
            return result
            
        except Exception as e:
            logger.error(f"Container scan failed for {full_image_name}: {str(e)}")
            raise
    
    async def _ensure_image_available(self, image_name: str):
        """Ensure container image is available locally"""
        try:
            self.docker_client.images.get(image_name)
        except docker.errors.ImageNotFound:
            logger.info(f"Pulling image {image_name}")
            self.docker_client.images.pull(image_name)
    
    async def _scan_vulnerabilities(
        self, 
        image_name: str,
        scan_options: Optional[Dict[str, Any]] = None
    ) -> List[Vulnerability]:
        """Scan for vulnerabilities using multiple tools"""
        all_vulnerabilities = []
        
        # Use primary scanner (Trivy by default)
        primary_scanner = scan_options.get("primary_scanner", "trivy") if scan_options else "trivy"
        
        if primary_scanner in self.scan_tools:
            vulnerabilities = await self.scan_tools[primary_scanner](image_name)
            all_vulnerabilities.extend(vulnerabilities)
        
        # Deduplicate vulnerabilities
        unique_vulnerabilities = self._deduplicate_vulnerabilities(all_vulnerabilities)
        
        return unique_vulnerabilities
    
    async def _scan_with_trivy(self, image_name: str) -> List[Vulnerability]:
        """Scan with Trivy vulnerability scanner"""
        try:
            # Run Trivy scan
            cmd = [
                "trivy", "image",
                "--format", "json",
                "--severity", "CRITICAL,HIGH,MEDIUM,LOW",
                image_name
            ]
            
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await process.communicate()
            
            if process.returncode != 0:
                logger.error(f"Trivy scan failed: {stderr.decode()}")
                return []
            
            # Parse Trivy output
            scan_result = json.loads(stdout.decode())
            vulnerabilities = []
            
            for result in scan_result.get("Results", []):
                for vuln in result.get("Vulnerabilities", []):
                    vulnerability = Vulnerability(
                        cve_id=vuln.get("VulnerabilityID", ""),
                        severity=VulnerabilitySeverity(vuln.get("Severity", "low").lower()),
                        package=vuln.get("PkgName", ""),
                        version=vuln.get("InstalledVersion", ""),
                        fixed_version=vuln.get("FixedVersion"),
                        description=vuln.get("Description", ""),
                        cvss_score=float(vuln.get("CVSS", {}).get("nvd", {}).get("V3Score", 0.0)),
                        references=vuln.get("References", [])
                    )
                    vulnerabilities.append(vulnerability)
            
            return vulnerabilities
            
        except Exception as e:
            logger.error(f"Trivy scan error: {str(e)}")
            return []
    
    async def _scan_with_grype(self, image_name: str) -> List[Vulnerability]:
        """Scan with Grype vulnerability scanner"""
        try:
            cmd = [
                "grype", image_name,
                "-o", "json"
            ]
            
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await process.communicate()
            
            if process.returncode != 0:
                logger.error(f"Grype scan failed: {stderr.decode()}")
                return []
            
            # Parse Grype output
            scan_result = json.loads(stdout.decode())
            vulnerabilities = []
            
            for match in scan_result.get("matches", []):
                vuln_data = match.get("vulnerability", {})
                artifact = match.get("artifact", {})
                
                vulnerability = Vulnerability(
                    cve_id=vuln_data.get("id", ""),
                    severity=VulnerabilitySeverity(vuln_data.get("severity", "low").lower()),
                    package=artifact.get("name", ""),
                    version=artifact.get("version", ""),
                    fixed_version=vuln_data.get("fix", {}).get("versions", [None])[0],
                    description=vuln_data.get("description", ""),
                    cvss_score=float(vuln_data.get("cvss", [{}])[0].get("metrics", {}).get("baseScore", 0.0)),
                    references=vuln_data.get("urls", [])
                )
                vulnerabilities.append(vulnerability)
            
            return vulnerabilities
            
        except Exception as e:
            logger.error(f"Grype scan error: {str(e)}")
            return []
    
    async def _scan_with_clair(self, image_name: str) -> List[Vulnerability]:
        """Scan with Clair vulnerability scanner"""
        # Placeholder for Clair integration
        logger.info("Clair scanner not implemented yet")
        return []
    
    async def _scan_misconfigurations(self, image_name: str) -> List[Misconfiguration]:
        """Scan for container misconfigurations"""
        misconfigurations = []
        
        # Dockerfile checks
        dockerfile_misconfigs = await self._check_dockerfile_misconfigurations(image_name)
        misconfigurations.extend(dockerfile_misconfigs)
        
        # Runtime configuration checks
        runtime_misconfigs = await self._check_runtime_misconfigurations(image_name)
        misconfigurations.extend(runtime_misconfigs)
        
        # Image layer checks
        layer_misconfigs = await self._check_image_layer_misconfigurations(image_name)
        misconfigurations.extend(layer_misconfigs)
        
        return misconfigurations
    
    async def _check_dockerfile_misconfigurations(self, image_name: str) -> List[Misconfiguration]:
        """Check Dockerfile for misconfigurations"""
        misconfigurations = []
        
        try:
            # Get image history to analyze Dockerfile commands
            image = self.docker_client.images.get(image_name)
            history = image.history()
            
            # Analyze each layer for misconfigurations
            for layer in history:
                created_by = layer.get("CreatedBy", "")
                
                # Check for common misconfigurations
                for check in self.misconfiguration_checks["dockerfile_checks"]:
                    if self._matches_pattern(created_by, check.get("pattern", "")):
                        misconfiguration = Misconfiguration(
                            check_id=check["id"],
                            type=check["type"],
                            severity=check["severity"],
                            title=check["title"],
                            description=check["description"],
                            remediation=check["remediation"]
                        )
                        misconfigurations.append(misconfiguration)
            
        except Exception as e:
            logger.error(f"Dockerfile misconfiguration check failed: {str(e)}")
        
        return misconfigurations
    
    async def _check_runtime_misconfigurations(self, image_name: str) -> List[Misconfiguration]:
        """Check runtime configuration misconfigurations"""
        misconfigurations = []
        
        try:
            # Inspect image configuration
            image = self.docker_client.images.get(image_name)
            config = image.attrs.get("Config", {})
            
            # Check user configuration
            user = config.get("User", "")
            if not user or user == "root" or user == "0":
                misconfiguration = Misconfiguration(
                    check_id="USER_ROOT",
                    type=MisconfigurationType.SECURITY,
                    severity=VulnerabilitySeverity.HIGH,
                    title="Container running as root",
                    description="Container is configured to run as root user",
                    remediation="Configure container to run as non-root user"
                )
                misconfigurations.append(misconfiguration)
            
            # Check exposed ports
            exposed_ports = config.get("ExposedPorts", {})
            for port in exposed_ports:
                if port.startswith("22/") or port.startswith("3389/"):
                    misconfiguration = Misconfiguration(
                        check_id="EXPOSED_ADMIN_PORT",
                        type=MisconfigurationType.SECURITY,
                        severity=VulnerabilitySeverity.HIGH,
                        title="Administrative port exposed",
                        description=f"Administrative port {port} is exposed",
                        remediation="Remove unnecessary port exposures"
                    )
                    misconfigurations.append(misconfiguration)
            
            # Check environment variables for secrets
            env_vars = config.get("Env", [])
            for env_var in env_vars:
                if any(secret_keyword in env_var.upper() for secret_keyword in ["PASSWORD", "SECRET", "KEY", "TOKEN"]):
                    misconfiguration = Misconfiguration(
                        check_id="EXPOSED_SECRETS",
                        type=MisconfigurationType.SECURITY,
                        severity=VulnerabilitySeverity.CRITICAL,
                        title="Secrets in environment variables",
                        description="Potential secrets found in environment variables",
                        remediation="Use secret management systems instead of environment variables"
                    )
                    misconfigurations.append(misconfiguration)
            
        except Exception as e:
            logger.error(f"Runtime misconfiguration check failed: {str(e)}")
        
        return misconfigurations
    
    async def _check_image_layer_misconfigurations(self, image_name: str) -> List[Misconfiguration]:
        """Check image layers for misconfigurations"""
        misconfigurations = []
        
        try:
            # Use dive or similar tool to analyze layers
            # For now, implement basic checks
            
            image = self.docker_client.images.get(image_name)
            
            # Check image size
            size_mb = image.attrs.get("Size", 0) / (1024 * 1024)
            if size_mb > 1000:  # 1GB
                misconfiguration = Misconfiguration(
                    check_id="LARGE_IMAGE_SIZE",
                    type=MisconfigurationType.PERFORMANCE,
                    severity=VulnerabilitySeverity.MEDIUM,
                    title="Large image size",
                    description=f"Image size is {size_mb:.1f}MB",
                    remediation="Optimize image size by removing unnecessary files and using multi-stage builds"
                )
                misconfigurations.append(misconfiguration)
            
            # Check number of layers
            layers = len(image.history())
            if layers > 50:
                misconfiguration = Misconfiguration(
                    check_id="TOO_MANY_LAYERS",
                    type=MisconfigurationType.PERFORMANCE,
                    severity=VulnerabilitySeverity.LOW,
                    title="Too many layers",
                    description=f"Image has {layers} layers",
                    remediation="Combine RUN commands to reduce layer count"
                )
                misconfigurations.append(misconfiguration)
            
        except Exception as e:
            logger.error(f"Image layer misconfiguration check failed: {str(e)}")
        
        return misconfigurations
    
    def _matches_pattern(self, text: str, pattern: str) -> bool:
        """Check if text matches pattern"""
        import re
        try:
            return bool(re.search(pattern, text, re.IGNORECASE | re.MULTILINE))
        except re.error:
            return False
    
    def _deduplicate_vulnerabilities(self, vulnerabilities: List[Vulnerability]) -> List[Vulnerability]:
        """Remove duplicate vulnerabilities"""
        seen = set()
        unique_vulnerabilities = []
        
        for vuln in vulnerabilities:
            key = (vuln.cve_id, vuln.package, vuln.version)
            if key not in seen:
                seen.add(key)
                unique_vulnerabilities.append(vuln)
        
        return unique_vulnerabilities
    
    def _calculate_security_score(
        self, 
        vulnerabilities: List[Vulnerability],
        misconfigurations: List[Misconfiguration]
    ) -> float:
        """Calculate overall security score"""
        base_score = 100.0
        
        # Deduct points for vulnerabilities
        for vuln in vulnerabilities:
            if vuln.severity == VulnerabilitySeverity.CRITICAL:
                base_score -= 20
            elif vuln.severity == VulnerabilitySeverity.HIGH:
                base_score -= 10
            elif vuln.severity == VulnerabilitySeverity.MEDIUM:
                base_score -= 5
            elif vuln.severity == VulnerabilitySeverity.LOW:
                base_score -= 1
        
        # Deduct points for misconfigurations
        for misconfig in misconfigurations:
            if misconfig.severity == VulnerabilitySeverity.CRITICAL:
                base_score -= 15
            elif misconfig.severity == VulnerabilitySeverity.HIGH:
                base_score -= 8
            elif misconfig.severity == VulnerabilitySeverity.MEDIUM:
                base_score -= 3
            elif misconfig.severity == VulnerabilitySeverity.LOW:
                base_score -= 1
        
        return max(0.0, base_score)
    
    def _calculate_compliance_score(self, misconfigurations: List[Misconfiguration]) -> float:
        """Calculate compliance score based on misconfigurations"""
        base_score = 100.0
        
        compliance_misconfigs = [
            m for m in misconfigurations 
            if m.type == MisconfigurationType.COMPLIANCE
        ]
        
        for misconfig in compliance_misconfigs:
            if misconfig.severity == VulnerabilitySeverity.CRITICAL:
                base_score -= 25
            elif misconfig.severity == VulnerabilitySeverity.HIGH:
                base_score -= 15
            elif misconfig.severity == VulnerabilitySeverity.MEDIUM:
                base_score -= 8
            elif misconfig.severity == VulnerabilitySeverity.LOW:
                base_score -= 3
        
        return max(0.0, base_score)
    
    async def generate_scan_report(self, scan_result: ScanResult) -> Dict[str, Any]:
        """Generate comprehensive scan report"""
        return {
            "summary": {
                "image": f"{scan_result.image_name}:{scan_result.image_tag}",
                "scan_timestamp": scan_result.scan_timestamp.isoformat(),
                "scan_duration": scan_result.scan_duration,
                "security_score": scan_result.security_score,
                "compliance_score": scan_result.compliance_score,
                "total_vulnerabilities": len(scan_result.vulnerabilities),
                "total_misconfigurations": len(scan_result.misconfigurations)
            },
            "vulnerabilities": {
                "critical": [v for v in scan_result.vulnerabilities if v.severity == VulnerabilitySeverity.CRITICAL],
                "high": [v for v in scan_result.vulnerabilities if v.severity == VulnerabilitySeverity.HIGH],
                "medium": [v for v in scan_result.vulnerabilities if v.severity == VulnerabilitySeverity.MEDIUM],
                "low": [v for v in scan_result.vulnerabilities if v.severity == VulnerabilitySeverity.LOW]
            },
            "misconfigurations": {
                "security": [m for m in scan_result.misconfigurations if m.type == MisconfigurationType.SECURITY],
                "compliance": [m for m in scan_result.misconfigurations if m.type == MisconfigurationType.COMPLIANCE],
                "performance": [m for m in scan_result.misconfigurations if m.type == MisconfigurationType.PERFORMANCE],
                "best_practice": [m for m in scan_result.misconfigurations if m.type == MisconfigurationType.BEST_PRACTICE]
            },
            "recommendations": self._generate_recommendations(scan_result),
            "metadata": scan_result.metadata
        }
    
    def _generate_recommendations(self, scan_result: ScanResult) -> List[str]:
        """Generate recommendations based on scan results"""
        recommendations = []
        
        # Vulnerability recommendations
        critical_vulns = [v for v in scan_result.vulnerabilities if v.severity == VulnerabilitySeverity.CRITICAL]
        if critical_vulns:
            recommendations.append("Immediately update packages with critical vulnerabilities")
        
        high_vulns = [v for v in scan_result.vulnerabilities if v.severity == VulnerabilitySeverity.HIGH]
        if high_vulns:
            recommendations.append("Update packages with high severity vulnerabilities")
        
        # Misconfiguration recommendations
        security_misconfigs = [m for m in scan_result.misconfigurations if m.type == MisconfigurationType.SECURITY]
        if security_misconfigs:
            recommendations.append("Fix security misconfigurations before deployment")
        
        # Score-based recommendations
        if scan_result.security_score < 70:
            recommendations.append("Security score is below acceptable threshold - review all findings")
        
        if scan_result.compliance_score < 80:
            recommendations.append("Compliance score needs improvement - address compliance issues")
        
        return recommendations