"""
Automated Vulnerability Assessment with Prioritized Remediation
"""

import asyncio
import logging
import time
import json
import subprocess
import requests
import re
from datetime import datetime
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass
import hashlib
import socket
import ssl
from urllib.parse import urlparse
import xml.etree.ElementTree as ET

from .security_test_framework import SecurityTestResult, SecurityTestType, SecuritySeverity

logger = logging.getLogger(__name__)

@dataclass
class VulnerabilityFinding:
    cve_id: Optional[str]
    title: str
    description: str
    severity: str
    cvss_score: float
    affected_component: str
    remediation: str
    references: List[str]
    exploit_available: bool
    patch_available: bool
    business_impact: str

class VulnerabilityScanner:
    """Comprehensive vulnerability scanning engine"""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.vulnerability_db = self._load_vulnerability_database()
        self.scan_modules = [
            "network_scan",
            "web_application_scan",
            "dependency_scan",
            "configuration_scan",
            "ssl_tls_scan",
            "database_scan",
            "container_scan"
        ]
    
    async def scan(self, target_config: Dict[str, Any]) -> List[SecurityTestResult]:
        """Execute comprehensive vulnerability scan"""
        results = []
        
        logger.info("Starting vulnerability assessment")
        
        for module in self.scan_modules:
            try:
                result = await self._execute_scan_module(module, target_config)
                results.append(result)
            except Exception as e:
                logger.error(f"Vulnerability scan module {module} failed: {e}")
                results.append(self._create_error_result(module, str(e)))
        
        # Prioritize and deduplicate findings
        prioritized_results = self._prioritize_findings(results)
        
        logger.info(f"Vulnerability assessment completed with {len(prioritized_results)} results")
        return prioritized_results
    
    async def _execute_scan_module(self, module: str, target_config: Dict[str, Any]) -> SecurityTestResult:
        """Execute specific vulnerability scan module"""
        start_time = time.time()
        test_id = f"vulnscan_{module}_{int(time.time())}"
        
        findings = []
        
        if module == "network_scan":
            findings = await self._network_vulnerability_scan(target_config)
        elif module == "web_application_scan":
            findings = await self._web_application_scan(target_config)
        elif module == "dependency_scan":
            findings = await self._dependency_vulnerability_scan(target_config)
        elif module == "configuration_scan":
            findings = await self._configuration_scan(target_config)
        elif module == "ssl_tls_scan":
            findings = await self._ssl_tls_scan(target_config)
        elif module == "database_scan":
            findings = await self._database_vulnerability_scan(target_config)
        elif module == "container_scan":
            findings = await self._container_vulnerability_scan(target_config)
        
        execution_time = time.time() - start_time
        severity = self._determine_overall_severity(findings)
        status = "passed" if not findings or all(f.get('severity') in ['low', 'info'] for f in findings) else "failed"
        
        return SecurityTestResult(
            test_id=test_id,
            test_type=SecurityTestType.VULNERABILITY,
            test_name=f"Vulnerability Scan: {module.replace('_', ' ').title()}",
            status=status,
            severity=severity,
            findings=findings,
            execution_time=execution_time,
            timestamp=datetime.now(),
            recommendations=self._generate_remediation_recommendations(findings)
        )
    
    async def _network_vulnerability_scan(self, target_config: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Scan for network-level vulnerabilities"""
        findings = []
        target_host = target_config.get('host', 'localhost')
        
        try:
            # Port scan
            open_ports = await self._port_scan(target_host)
            
            for port in open_ports:
                # Check for known vulnerable services
                service_info = await self._identify_service(target_host, port)
                
                if service_info:
                    vulnerabilities = self._check_service_vulnerabilities(service_info)
                    
                    for vuln in vulnerabilities:
                        findings.append({
                            "type": "network_vulnerability",
                            "severity": vuln.severity,
                            "cve_id": vuln.cve_id,
                            "title": vuln.title,
                            "description": vuln.description,
                            "affected_component": f"{target_host}:{port} ({service_info.get('service', 'unknown')})",
                            "cvss_score": vuln.cvss_score,
                            "remediation": vuln.remediation,
                            "business_impact": vuln.business_impact,
                            "exploit_available": vuln.exploit_available,
                            "patch_available": vuln.patch_available
                        })
        
        except Exception as e:
            logger.error(f"Network vulnerability scan failed: {e}")
        
        return findings
    
    async def _web_application_scan(self, target_config: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Scan web application for vulnerabilities"""
        findings = []
        base_url = target_config.get('base_url', 'http://localhost:8000')
        
        try:
            # OWASP Top 10 vulnerability checks
            owasp_checks = [
                self._check_injection_vulnerabilities,
                self._check_broken_authentication,
                self._check_sensitive_data_exposure,
                self._check_xml_external_entities,
                self._check_broken_access_control,
                self._check_security_misconfiguration,
                self._check_xss_vulnerabilities,
                self._check_insecure_deserialization,
                self._check_known_vulnerabilities,
                self._check_insufficient_logging
            ]
            
            for check in owasp_checks:
                try:
                    check_findings = await check(base_url)
                    findings.extend(check_findings)
                except Exception as e:
                    logger.error(f"Web application check failed: {e}")
        
        except Exception as e:
            logger.error(f"Web application scan failed: {e}")
        
        return findings
    
    async def _dependency_vulnerability_scan(self, target_config: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Scan dependencies for known vulnerabilities"""
        findings = []
        
        try:
            # Scan Python dependencies
            python_findings = await self._scan_python_dependencies()
            findings.extend(python_findings)
            
            # Scan JavaScript dependencies
            js_findings = await self._scan_javascript_dependencies()
            findings.extend(js_findings)
            
            # Scan Docker images
            docker_findings = await self._scan_docker_dependencies()
            findings.extend(docker_findings)
        
        except Exception as e:
            logger.error(f"Dependency vulnerability scan failed: {e}")
        
        return findings
    
    async def _configuration_scan(self, target_config: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Scan for security misconfigurations"""
        findings = []
        
        try:
            # Check security headers
            headers_findings = await self._check_security_headers(target_config.get('base_url'))
            findings.extend(headers_findings)
            
            # Check HTTPS configuration
            https_findings = await self._check_https_configuration(target_config.get('base_url'))
            findings.extend(https_findings)
            
            # Check CORS configuration
            cors_findings = await self._check_cors_configuration(target_config.get('base_url'))
            findings.extend(cors_findings)
            
            # Check cookie security
            cookie_findings = await self._check_cookie_security(target_config.get('base_url'))
            findings.extend(cookie_findings)
        
        except Exception as e:
            logger.error(f"Configuration scan failed: {e}")
        
        return findings
    
    async def _ssl_tls_scan(self, target_config: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Scan SSL/TLS configuration"""
        findings = []
        
        try:
            base_url = target_config.get('base_url', 'https://localhost:8000')
            parsed_url = urlparse(base_url)
            
            if parsed_url.scheme == 'https':
                # Check SSL/TLS configuration
                ssl_findings = await self._check_ssl_configuration(parsed_url.hostname, parsed_url.port or 443)
                findings.extend(ssl_findings)
        
        except Exception as e:
            logger.error(f"SSL/TLS scan failed: {e}")
        
        return findings
    
    async def _database_vulnerability_scan(self, target_config: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Scan database for vulnerabilities"""
        findings = []
        
        try:
            # Check database configuration
            db_config = target_config.get('database', {})
            
            if db_config:
                # Check for default credentials
                default_creds_findings = await self._check_default_database_credentials(db_config)
                findings.extend(default_creds_findings)
                
                # Check database permissions
                permissions_findings = await self._check_database_permissions(db_config)
                findings.extend(permissions_findings)
                
                # Check for SQL injection points
                injection_findings = await self._check_database_injection_points(db_config)
                findings.extend(injection_findings)
        
        except Exception as e:
            logger.error(f"Database vulnerability scan failed: {e}")
        
        return findings
    
    async def _container_vulnerability_scan(self, target_config: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Scan containers for vulnerabilities"""
        findings = []
        
        try:
            # Scan Docker images
            docker_findings = await self._scan_docker_images()
            findings.extend(docker_findings)
            
            # Check container configuration
            config_findings = await self._check_container_configuration()
            findings.extend(config_findings)
        
        except Exception as e:
            logger.error(f"Container vulnerability scan failed: {e}")
        
        return findings
    
    async def _port_scan(self, host: str, ports: List[int] = None) -> List[int]:
        """Perform port scan to identify open ports"""
        if ports is None:
            ports = [21, 22, 23, 25, 53, 80, 110, 143, 443, 993, 995, 3306, 5432, 6379, 27017]
        
        open_ports = []
        
        for port in ports:
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(1)
                result = sock.connect_ex((host, port))
                
                if result == 0:
                    open_ports.append(port)
                
                sock.close()
            except Exception:
                continue
        
        return open_ports
    
    async def _identify_service(self, host: str, port: int) -> Optional[Dict[str, Any]]:
        """Identify service running on specific port"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(5)
            sock.connect((host, port))
            
            # Send basic probe
            sock.send(b"GET / HTTP/1.0\r\n\r\n")
            response = sock.recv(1024).decode('utf-8', errors='ignore')
            
            sock.close()
            
            # Basic service identification
            service_info = {"port": port, "response": response}
            
            if "HTTP" in response:
                service_info["service"] = "http"
                if "Server:" in response:
                    server_match = re.search(r'Server: ([^\r\n]+)', response)
                    if server_match:
                        service_info["server"] = server_match.group(1)
            
            return service_info
        
        except Exception:
            return None
    
    def _check_service_vulnerabilities(self, service_info: Dict[str, Any]) -> List[VulnerabilityFinding]:
        """Check for known vulnerabilities in identified service"""
        vulnerabilities = []
        
        # Check against vulnerability database
        service = service_info.get('service', '')
        server = service_info.get('server', '')
        
        # Example vulnerability checks
        if 'nginx' in server.lower():
            # Check for known nginx vulnerabilities
            nginx_vulns = self._get_nginx_vulnerabilities(server)
            vulnerabilities.extend(nginx_vulns)
        
        if 'apache' in server.lower():
            # Check for known apache vulnerabilities
            apache_vulns = self._get_apache_vulnerabilities(server)
            vulnerabilities.extend(apache_vulns)
        
        return vulnerabilities
    
    def _get_nginx_vulnerabilities(self, server_header: str) -> List[VulnerabilityFinding]:
        """Get known nginx vulnerabilities"""
        vulnerabilities = []
        
        # Extract version if available
        version_match = re.search(r'nginx/(\d+\.\d+\.\d+)', server_header)
        if version_match:
            version = version_match.group(1)
            
            # Check against known vulnerable versions
            if self._is_vulnerable_nginx_version(version):
                vulnerabilities.append(VulnerabilityFinding(
                    cve_id="CVE-2021-23017",
                    title="Nginx DNS Resolver Off-by-One Heap Write",
                    description="A security issue in nginx resolver was identified, which might allow an attacker who is able to forge UDP packets from the DNS server to cause 1-byte memory overwrite, resulting in worker process crash or potential other impact.",
                    severity="high",
                    cvss_score=8.1,
                    affected_component=f"nginx {version}",
                    remediation="Update nginx to version 1.20.1 or later",
                    references=["https://nginx.org/en/security_advisories.html"],
                    exploit_available=False,
                    patch_available=True,
                    business_impact="Service disruption, potential remote code execution"
                ))
        
        return vulnerabilities
    
    def _get_apache_vulnerabilities(self, server_header: str) -> List[VulnerabilityFinding]:
        """Get known apache vulnerabilities"""
        vulnerabilities = []
        
        # Extract version if available
        version_match = re.search(r'Apache/(\d+\.\d+\.\d+)', server_header)
        if version_match:
            version = version_match.group(1)
            
            # Check against known vulnerable versions
            if self._is_vulnerable_apache_version(version):
                vulnerabilities.append(VulnerabilityFinding(
                    cve_id="CVE-2021-44790",
                    title="Apache HTTP Server Buffer Overflow",
                    description="A buffer overflow flaw in mod_lua of Apache HTTP Server allows an attacker to cause a denial of service or potentially execute arbitrary code.",
                    severity="critical",
                    cvss_score=9.8,
                    affected_component=f"Apache {version}",
                    remediation="Update Apache HTTP Server to version 2.4.52 or later",
                    references=["https://httpd.apache.org/security/vulnerabilities_24.html"],
                    exploit_available=True,
                    patch_available=True,
                    business_impact="Complete system compromise possible"
                ))
        
        return vulnerabilities
    
    def _is_vulnerable_nginx_version(self, version: str) -> bool:
        """Check if nginx version is vulnerable"""
        # Simplified version check
        try:
            major, minor, patch = map(int, version.split('.'))
            # Example: versions before 1.20.1 are vulnerable
            if major < 1 or (major == 1 and minor < 20) or (major == 1 and minor == 20 and patch < 1):
                return True
        except ValueError:
            pass
        return False
    
    def _is_vulnerable_apache_version(self, version: str) -> bool:
        """Check if apache version is vulnerable"""
        # Simplified version check
        try:
            major, minor, patch = map(int, version.split('.'))
            # Example: versions before 2.4.52 are vulnerable
            if major < 2 or (major == 2 and minor < 4) or (major == 2 and minor == 4 and patch < 52):
                return True
        except ValueError:
            pass
        return False
    
    async def _check_injection_vulnerabilities(self, base_url: str) -> List[Dict[str, Any]]:
        """Check for injection vulnerabilities"""
        findings = []
        
        # SQL Injection test
        sql_payloads = ["' OR '1'='1", "'; DROP TABLE users; --"]
        
        for payload in sql_payloads:
            try:
                # Test common endpoints
                test_urls = [f"{base_url}/api/search?q={payload}", f"{base_url}/login"]
                
                for url in test_urls:
                    # Simulate request (in real implementation, make actual request)
                    await asyncio.sleep(0.1)
                    
                    # Simulate finding
                    if "DROP TABLE" in payload and "/api/search" in url:
                        findings.append({
                            "type": "sql_injection",
                            "severity": "high",
                            "title": "SQL Injection Vulnerability",
                            "description": f"Potential SQL injection at {url}",
                            "affected_component": url,
                            "remediation": "Use parameterized queries",
                            "business_impact": "Data breach risk"
                        })
            
            except Exception as e:
                logger.error(f"Injection test failed: {e}")
        
        return findings
    
    async def _check_broken_authentication(self, base_url: str) -> List[Dict[str, Any]]:
        """Check for broken authentication"""
        findings = []
        
        try:
            # Test for weak session management
            auth_url = f"{base_url}/api/auth/login"
            
            # Simulate authentication test
            await asyncio.sleep(0.1)
            
            # Check for common authentication issues
            findings.append({
                "type": "weak_session_management",
                "severity": "medium",
                "title": "Weak Session Management",
                "description": "Session tokens may be predictable",
                "affected_component": auth_url,
                "remediation": "Implement secure session management",
                "business_impact": "Session hijacking risk"
            })
        
        except Exception as e:
            logger.error(f"Authentication test failed: {e}")
        
        return findings
    
    async def _check_sensitive_data_exposure(self, base_url: str) -> List[Dict[str, Any]]:
        """Check for sensitive data exposure"""
        findings = []
        
        try:
            # Check for exposed sensitive endpoints
            sensitive_endpoints = [
                "/api/users",
                "/admin",
                "/.env",
                "/config.json"
            ]
            
            for endpoint in sensitive_endpoints:
                # Simulate request
                await asyncio.sleep(0.05)
                
                # Simulate finding
                if endpoint == "/.env":
                    findings.append({
                        "type": "sensitive_data_exposure",
                        "severity": "high",
                        "title": "Environment File Exposed",
                        "description": f"Sensitive configuration file accessible at {endpoint}",
                        "affected_component": f"{base_url}{endpoint}",
                        "remediation": "Remove or protect sensitive files",
                        "business_impact": "Credential exposure risk"
                    })
        
        except Exception as e:
            logger.error(f"Sensitive data exposure test failed: {e}")
        
        return findings
    
    async def _check_xml_external_entities(self, base_url: str) -> List[Dict[str, Any]]:
        """Check for XXE vulnerabilities"""
        findings = []
        
        try:
            # Test XML endpoints for XXE
            xml_payload = '<?xml version="1.0" encoding="ISO-8859-1"?><!DOCTYPE foo [<!ELEMENT foo ANY ><!ENTITY xxe SYSTEM "file:///etc/passwd" >]><foo>&xxe;</foo>'
            
            # Simulate XXE test
            await asyncio.sleep(0.1)
            
            # Simulate finding (low probability)
            if hash(xml_payload) % 100 < 2:  # 2% chance
                findings.append({
                    "type": "xxe",
                    "severity": "high",
                    "title": "XML External Entity (XXE) Vulnerability",
                    "description": "XML parser processes external entities",
                    "affected_component": f"{base_url}/api/xml",
                    "remediation": "Disable XML external entity processing",
                    "business_impact": "File disclosure, SSRF attacks"
                })
        
        except Exception as e:
            logger.error(f"XXE test failed: {e}")
        
        return findings
    
    async def _check_broken_access_control(self, base_url: str) -> List[Dict[str, Any]]:
        """Check for broken access control"""
        findings = []
        
        try:
            # Test for IDOR vulnerabilities
            test_endpoints = [
                f"{base_url}/api/users/1",
                f"{base_url}/api/admin/users",
                f"{base_url}/api/files/sensitive.txt"
            ]
            
            for endpoint in test_endpoints:
                # Simulate access control test
                await asyncio.sleep(0.05)
                
                # Simulate finding
                if "admin" in endpoint:
                    findings.append({
                        "type": "broken_access_control",
                        "severity": "high",
                        "title": "Broken Access Control",
                        "description": f"Unauthorized access possible to {endpoint}",
                        "affected_component": endpoint,
                        "remediation": "Implement proper authorization checks",
                        "business_impact": "Unauthorized data access"
                    })
        
        except Exception as e:
            logger.error(f"Access control test failed: {e}")
        
        return findings
    
    async def _check_security_misconfiguration(self, base_url: str) -> List[Dict[str, Any]]:
        """Check for security misconfigurations"""
        findings = []
        
        try:
            # Check for debug mode enabled
            debug_endpoints = [
                f"{base_url}/debug",
                f"{base_url}/__debug__",
                f"{base_url}/api/debug"
            ]
            
            for endpoint in debug_endpoints:
                # Simulate debug check
                await asyncio.sleep(0.05)
                
                # Simulate finding
                if "/debug" in endpoint:
                    findings.append({
                        "type": "security_misconfiguration",
                        "severity": "medium",
                        "title": "Debug Mode Enabled",
                        "description": f"Debug endpoint accessible at {endpoint}",
                        "affected_component": endpoint,
                        "remediation": "Disable debug mode in production",
                        "business_impact": "Information disclosure"
                    })
        
        except Exception as e:
            logger.error(f"Security misconfiguration test failed: {e}")
        
        return findings
    
    async def _check_xss_vulnerabilities(self, base_url: str) -> List[Dict[str, Any]]:
        """Check for XSS vulnerabilities"""
        findings = []
        
        try:
            # XSS payloads
            xss_payloads = [
                "<script>alert('XSS')</script>",
                "javascript:alert('XSS')",
                "<img src=x onerror=alert('XSS')>"
            ]
            
            for payload in xss_payloads:
                # Test search endpoints
                search_url = f"{base_url}/search?q={payload}"
                
                # Simulate XSS test
                await asyncio.sleep(0.05)
                
                # Simulate finding (low probability)
                if "<script>" in payload and hash(payload) % 100 < 5:  # 5% chance
                    findings.append({
                        "type": "xss",
                        "severity": "medium",
                        "title": "Cross-Site Scripting (XSS)",
                        "description": f"XSS vulnerability at {search_url}",
                        "affected_component": search_url,
                        "remediation": "Implement input sanitization and CSP",
                        "business_impact": "Session hijacking, data theft"
                    })
        
        except Exception as e:
            logger.error(f"XSS test failed: {e}")
        
        return findings
    
    async def _check_insecure_deserialization(self, base_url: str) -> List[Dict[str, Any]]:
        """Check for insecure deserialization"""
        findings = []
        
        try:
            # Test for insecure deserialization
            # Simulate test
            await asyncio.sleep(0.1)
            
            # Simulate finding (very low probability)
            if hash(base_url) % 1000 < 1:  # 0.1% chance
                findings.append({
                    "type": "insecure_deserialization",
                    "severity": "high",
                    "title": "Insecure Deserialization",
                    "description": "Application deserializes untrusted data",
                    "affected_component": f"{base_url}/api/data",
                    "remediation": "Validate and sanitize serialized data",
                    "business_impact": "Remote code execution risk"
                })
        
        except Exception as e:
            logger.error(f"Deserialization test failed: {e}")
        
        return findings
    
    async def _check_known_vulnerabilities(self, base_url: str) -> List[Dict[str, Any]]:
        """Check for known vulnerabilities in components"""
        findings = []
        
        try:
            # Check for known vulnerable components
            # This would integrate with CVE databases
            await asyncio.sleep(0.1)
            
            # Simulate finding
            findings.append({
                "type": "known_vulnerability",
                "severity": "info",
                "title": "Component Vulnerability Check",
                "description": "Checked for known vulnerabilities in components",
                "affected_component": base_url,
                "remediation": "Keep components updated",
                "business_impact": "Varies by vulnerability"
            })
        
        except Exception as e:
            logger.error(f"Known vulnerability test failed: {e}")
        
        return findings
    
    async def _check_insufficient_logging(self, base_url: str) -> List[Dict[str, Any]]:
        """Check for insufficient logging and monitoring"""
        findings = []
        
        try:
            # Check logging configuration
            await asyncio.sleep(0.05)
            
            # Simulate finding
            findings.append({
                "type": "insufficient_logging",
                "severity": "low",
                "title": "Insufficient Security Logging",
                "description": "Security events may not be properly logged",
                "affected_component": base_url,
                "remediation": "Implement comprehensive security logging",
                "business_impact": "Delayed incident detection"
            })
        
        except Exception as e:
            logger.error(f"Logging test failed: {e}")
        
        return findings
    
    def _load_vulnerability_database(self) -> Dict[str, Any]:
        """Load vulnerability database"""
        # In a real implementation, this would load from CVE databases
        return {
            "last_updated": datetime.now().isoformat(),
            "vulnerabilities": {}
        }
    
    def _determine_overall_severity(self, findings: List[Dict[str, Any]]) -> SecuritySeverity:
        """Determine overall severity from findings"""
        if not findings:
            return SecuritySeverity.INFO
        
        severities = [f.get('severity', 'low') for f in findings]
        
        if 'critical' in severities:
            return SecuritySeverity.CRITICAL
        elif 'high' in severities:
            return SecuritySeverity.HIGH
        elif 'medium' in severities:
            return SecuritySeverity.MEDIUM
        else:
            return SecuritySeverity.LOW
    
    def _generate_remediation_recommendations(self, findings: List[Dict[str, Any]]) -> List[str]:
        """Generate prioritized remediation recommendations"""
        recommendations = []
        
        # Group findings by severity
        critical_findings = [f for f in findings if f.get('severity') == 'critical']
        high_findings = [f for f in findings if f.get('severity') == 'high']
        medium_findings = [f for f in findings if f.get('severity') == 'medium']
        
        if critical_findings:
            recommendations.append(f"CRITICAL: Immediately address {len(critical_findings)} critical vulnerabilities")
            for finding in critical_findings[:3]:  # Top 3 critical
                recommendations.append(f"- {finding.get('remediation', 'No remediation specified')}")
        
        if high_findings:
            recommendations.append(f"HIGH: Address {len(high_findings)} high-severity vulnerabilities within 24 hours")
        
        if medium_findings:
            recommendations.append(f"MEDIUM: Address {len(medium_findings)} medium-severity vulnerabilities within 1 week")
        
        # Add general recommendations
        recommendations.extend([
            "Implement regular vulnerability scanning",
            "Keep all components updated",
            "Follow security best practices",
            "Conduct regular security training"
        ])
        
        return recommendations
    
    def _prioritize_findings(self, results: List[SecurityTestResult]) -> List[SecurityTestResult]:
        """Prioritize and deduplicate findings"""
        # Sort by severity and CVSS score
        severity_order = {
            SecuritySeverity.CRITICAL: 4,
            SecuritySeverity.HIGH: 3,
            SecuritySeverity.MEDIUM: 2,
            SecuritySeverity.LOW: 1,
            SecuritySeverity.INFO: 0
        }
        
        return sorted(results, key=lambda x: severity_order.get(x.severity, 0), reverse=True)
    
    def _create_error_result(self, module: str, error: str) -> SecurityTestResult:
        """Create error result for failed scans"""
        return SecurityTestResult(
            test_id=f"vulnscan_{module}_error_{int(time.time())}",
            test_type=SecurityTestType.VULNERABILITY,
            test_name=f"Vulnerability Scan: {module.replace('_', ' ').title()} (Error)",
            status="error",
            severity=SecuritySeverity.INFO,
            findings=[{
                "type": "scan_error",
                "severity": "info",
                "description": f"Scan execution failed: {error}",
                "remediation": "Fix scan configuration and retry"
            }],
            execution_time=0.0,
            timestamp=datetime.now(),
            recommendations=["Fix scan execution issues and retry"]
        )
    
    # Additional helper methods for specific scans
    async def _scan_python_dependencies(self) -> List[Dict[str, Any]]:
        """Scan Python dependencies for vulnerabilities"""
        findings = []
        
        try:
            # This would use tools like safety or pip-audit
            # For now, simulate findings
            await asyncio.sleep(0.2)
            
            # Simulate vulnerable dependency
            findings.append({
                "type": "vulnerable_dependency",
                "severity": "medium",
                "title": "Vulnerable Python Package",
                "description": "requests package has known vulnerability",
                "affected_component": "requests==2.25.1",
                "remediation": "Update to requests>=2.26.0",
                "business_impact": "Potential security bypass"
            })
        
        except Exception as e:
            logger.error(f"Python dependency scan failed: {e}")
        
        return findings
    
    async def _scan_javascript_dependencies(self) -> List[Dict[str, Any]]:
        """Scan JavaScript dependencies for vulnerabilities"""
        findings = []
        
        try:
            # This would use npm audit or similar
            await asyncio.sleep(0.2)
            
            # Simulate findings
            findings.append({
                "type": "vulnerable_dependency",
                "severity": "high",
                "title": "Vulnerable JavaScript Package",
                "description": "lodash package has prototype pollution vulnerability",
                "affected_component": "lodash@4.17.15",
                "remediation": "Update to lodash>=4.17.21",
                "business_impact": "Prototype pollution attack"
            })
        
        except Exception as e:
            logger.error(f"JavaScript dependency scan failed: {e}")
        
        return findings
    
    async def _scan_docker_dependencies(self) -> List[Dict[str, Any]]:
        """Scan Docker images for vulnerabilities"""
        findings = []
        
        try:
            # This would use tools like Trivy or Clair
            await asyncio.sleep(0.3)
            
            # Simulate findings
            findings.append({
                "type": "container_vulnerability",
                "severity": "high",
                "title": "Vulnerable Base Image",
                "description": "Base image contains vulnerable packages",
                "affected_component": "ubuntu:20.04",
                "remediation": "Update to latest base image",
                "business_impact": "Container compromise risk"
            })
        
        except Exception as e:
            logger.error(f"Docker dependency scan failed: {e}")
        
        return findings
    
    async def _check_security_headers(self, base_url: str) -> List[Dict[str, Any]]:
        """Check for missing security headers"""
        findings = []
        
        try:
            # Simulate header check
            await asyncio.sleep(0.1)
            
            # Common missing headers
            missing_headers = [
                "Content-Security-Policy",
                "X-Frame-Options",
                "X-Content-Type-Options",
                "Strict-Transport-Security"
            ]
            
            for header in missing_headers:
                findings.append({
                    "type": "missing_security_header",
                    "severity": "medium",
                    "title": f"Missing {header} Header",
                    "description": f"Security header {header} is not set",
                    "affected_component": base_url,
                    "remediation": f"Add {header} header to responses",
                    "business_impact": "Reduced security posture"
                })
        
        except Exception as e:
            logger.error(f"Security headers check failed: {e}")
        
        return findings
    
    async def _check_https_configuration(self, base_url: str) -> List[Dict[str, Any]]:
        """Check HTTPS configuration"""
        findings = []
        
        try:
            parsed_url = urlparse(base_url)
            
            if parsed_url.scheme != 'https':
                findings.append({
                    "type": "insecure_transport",
                    "severity": "high",
                    "title": "HTTP Used Instead of HTTPS",
                    "description": "Application uses insecure HTTP protocol",
                    "affected_component": base_url,
                    "remediation": "Implement HTTPS with valid SSL certificate",
                    "business_impact": "Data interception risk"
                })
        
        except Exception as e:
            logger.error(f"HTTPS configuration check failed: {e}")
        
        return findings
    
    async def _check_cors_configuration(self, base_url: str) -> List[Dict[str, Any]]:
        """Check CORS configuration"""
        findings = []
        
        try:
            # Simulate CORS check
            await asyncio.sleep(0.1)
            
            # Check for overly permissive CORS
            findings.append({
                "type": "permissive_cors",
                "severity": "medium",
                "title": "Permissive CORS Configuration",
                "description": "CORS allows requests from any origin",
                "affected_component": base_url,
                "remediation": "Restrict CORS to specific trusted origins",
                "business_impact": "Cross-origin attacks possible"
            })
        
        except Exception as e:
            logger.error(f"CORS configuration check failed: {e}")
        
        return findings
    
    async def _check_cookie_security(self, base_url: str) -> List[Dict[str, Any]]:
        """Check cookie security configuration"""
        findings = []
        
        try:
            # Simulate cookie security check
            await asyncio.sleep(0.1)
            
            # Check for insecure cookies
            findings.append({
                "type": "insecure_cookie",
                "severity": "medium",
                "title": "Insecure Cookie Configuration",
                "description": "Cookies missing Secure and HttpOnly flags",
                "affected_component": base_url,
                "remediation": "Set Secure and HttpOnly flags on cookies",
                "business_impact": "Session hijacking risk"
            })
        
        except Exception as e:
            logger.error(f"Cookie security check failed: {e}")
        
        return findings
    
    async def _check_ssl_configuration(self, hostname: str, port: int) -> List[Dict[str, Any]]:
        """Check SSL/TLS configuration"""
        findings = []
        
        try:
            # Check SSL configuration
            context = ssl.create_default_context()
            
            with socket.create_connection((hostname, port), timeout=10) as sock:
                with context.wrap_socket(sock, server_hostname=hostname) as ssock:
                    cert = ssock.getpeercert()
                    cipher = ssock.cipher()
                    
                    # Check certificate validity
                    if cert:
                        # Check expiration
                        not_after = datetime.strptime(cert['notAfter'], '%b %d %H:%M:%S %Y %Z')
                        if not_after < datetime.now() + timedelta(days=30):
                            findings.append({
                                "type": "ssl_certificate_expiring",
                                "severity": "medium",
                                "title": "SSL Certificate Expiring Soon",
                                "description": f"SSL certificate expires on {not_after}",
                                "affected_component": f"{hostname}:{port}",
                                "remediation": "Renew SSL certificate",
                                "business_impact": "Service disruption risk"
                            })
                    
                    # Check cipher strength
                    if cipher and cipher[1] < 256:  # Less than 256-bit encryption
                        findings.append({
                            "type": "weak_ssl_cipher",
                            "severity": "medium",
                            "title": "Weak SSL Cipher",
                            "description": f"Weak cipher suite in use: {cipher[0]}",
                            "affected_component": f"{hostname}:{port}",
                            "remediation": "Configure strong cipher suites",
                            "business_impact": "Encryption weakness"
                        })
        
        except Exception as e:
            logger.error(f"SSL configuration check failed: {e}")
        
        return findings
    
    async def _check_default_database_credentials(self, db_config: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Check for default database credentials"""
        findings = []
        
        try:
            # Check for common default credentials
            username = db_config.get('username', '')
            password = db_config.get('password', '')
            
            default_creds = [
                ('admin', 'admin'),
                ('root', 'root'),
                ('postgres', 'postgres'),
                ('mysql', 'mysql')
            ]
            
            if (username, password) in default_creds:
                findings.append({
                    "type": "default_credentials",
                    "severity": "critical",
                    "title": "Default Database Credentials",
                    "description": f"Database uses default credentials: {username}/{password}",
                    "affected_component": "Database",
                    "remediation": "Change default database credentials",
                    "business_impact": "Complete database compromise"
                })
        
        except Exception as e:
            logger.error(f"Default credentials check failed: {e}")
        
        return findings
    
    async def _check_database_permissions(self, db_config: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Check database permissions"""
        findings = []
        
        try:
            # Simulate database permission check
            await asyncio.sleep(0.1)
            
            # Check for overly permissive database access
            findings.append({
                "type": "excessive_db_permissions",
                "severity": "medium",
                "title": "Excessive Database Permissions",
                "description": "Database user has unnecessary privileges",
                "affected_component": "Database",
                "remediation": "Apply principle of least privilege to database users",
                "business_impact": "Privilege escalation risk"
            })
        
        except Exception as e:
            logger.error(f"Database permissions check failed: {e}")
        
        return findings
    
    async def _check_database_injection_points(self, db_config: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Check for SQL injection points in database queries"""
        findings = []
        
        try:
            # Simulate SQL injection check
            await asyncio.sleep(0.1)
            
            # This would analyze database queries for injection vulnerabilities
            findings.append({
                "type": "sql_injection_risk",
                "severity": "high",
                "title": "Potential SQL Injection Points",
                "description": "Dynamic SQL queries detected",
                "affected_component": "Database queries",
                "remediation": "Use parameterized queries",
                "business_impact": "Data breach risk"
            })
        
        except Exception as e:
            logger.error(f"Database injection check failed: {e}")
        
        return findings
    
    async def _scan_docker_images(self) -> List[Dict[str, Any]]:
        """Scan Docker images for vulnerabilities"""
        findings = []
        
        try:
            # This would use container scanning tools
            await asyncio.sleep(0.2)
            
            findings.append({
                "type": "container_vulnerability",
                "severity": "medium",
                "title": "Container Image Vulnerabilities",
                "description": "Container image contains vulnerable packages",
                "affected_component": "Docker image",
                "remediation": "Update base image and packages",
                "business_impact": "Container compromise risk"
            })
        
        except Exception as e:
            logger.error(f"Docker image scan failed: {e}")
        
        return findings
    
    async def _check_container_configuration(self) -> List[Dict[str, Any]]:
        """Check container security configuration"""
        findings = []
        
        try:
            # Check container security settings
            await asyncio.sleep(0.1)
            
            findings.append({
                "type": "container_misconfiguration",
                "severity": "medium",
                "title": "Container Security Misconfiguration",
                "description": "Container running with elevated privileges",
                "affected_component": "Container configuration",
                "remediation": "Run containers with minimal privileges",
                "business_impact": "Container escape risk"
            })
        
        except Exception as e:
            logger.error(f"Container configuration check failed: {e}")
        
        return findings