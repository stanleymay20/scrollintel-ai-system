"""
Third-Party Software Vulnerability Scanner with Backdoor Detection
Implements comprehensive scanning of vendor software and dependencies
"""

import asyncio
import json
import hashlib
import subprocess
import tempfile
import zipfile
import tarfile
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Set
from dataclasses import dataclass, asdict
from enum import Enum
from pathlib import Path
import re
import requests
import yara

class VulnerabilitySeverity(Enum):
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"

class ScanType(Enum):
    DEPENDENCY_SCAN = "dependency_scan"
    BINARY_ANALYSIS = "binary_analysis"
    SOURCE_CODE_SCAN = "source_code_scan"
    BACKDOOR_DETECTION = "backdoor_detection"
    MALWARE_SCAN = "malware_scan"

@dataclass
class Vulnerability:
    cve_id: str
    severity: VulnerabilitySeverity
    score: float
    description: str
    affected_component: str
    version_range: str
    fix_available: bool
    fix_version: Optional[str]
    published_date: datetime
    discovered_date: datetime

@dataclass
class BackdoorIndicator:
    indicator_type: str
    description: str
    confidence: float
    file_path: str
    line_number: Optional[int]
    code_snippet: Optional[str]
    risk_level: str

@dataclass
class ScanResult:
    scan_id: str
    vendor_id: str
    software_name: str
    software_version: str
    scan_type: ScanType
    vulnerabilities: List[Vulnerability]
    backdoor_indicators: List[BackdoorIndicator]
    malware_detected: bool
    overall_risk_score: float
    scan_duration: float
    scanned_files: int
    scan_timestamp: datetime
    scanner_version: str

class ThirdPartySoftwareScanner:
    def __init__(self, config_path: str = "security/config/scanner_config.yaml"):
        self.config = self._load_config(config_path)
        self.vulnerability_db = self._initialize_vulnerability_db()
        self.backdoor_patterns = self._load_backdoor_patterns()
        self.malware_signatures = self._load_malware_signatures()
        
    def _load_config(self, config_path: str) -> Dict[str, Any]:
        """Load scanner configuration"""
        default_config = {
            "scan_timeout": 3600,  # seconds
            "max_file_size": 100 * 1024 * 1024,  # 100MB
            "supported_formats": [".zip", ".tar", ".tar.gz", ".jar", ".war", ".exe", ".dll"],
            "vulnerability_sources": [
                "https://services.nvd.nist.gov/rest/json/cves/2.0",
                "https://api.osv.dev/v1/query"
            ],
            "backdoor_detection": {
                "enabled": True,
                "confidence_threshold": 0.7,
                "scan_depth": 10
            },
            "malware_detection": {
                "enabled": True,
                "signature_update_interval": 86400  # 24 hours
            }
        }
        
        try:
            # In production, load from actual config file
            return default_config
        except Exception:
            return default_config
    
    def _initialize_vulnerability_db(self) -> Dict[str, Any]:
        """Initialize vulnerability database"""
        return {
            "cve_cache": {},
            "last_updated": datetime.now(),
            "update_interval": timedelta(hours=6)
        }
    
    def _load_backdoor_patterns(self) -> List[Dict[str, Any]]:
        """Load backdoor detection patterns"""
        return [
            {
                "name": "suspicious_network_calls",
                "pattern": r"(socket\.connect|urllib\.request|requests\.get|fetch)\s*\(\s*['\"]https?://[^'\"]*['\"]",
                "confidence": 0.6,
                "description": "Suspicious outbound network connections"
            },
            {
                "name": "base64_encoded_payloads",
                "pattern": r"base64\.b64decode\s*\(\s*['\"][A-Za-z0-9+/=]{50,}['\"]",
                "confidence": 0.8,
                "description": "Base64 encoded payloads that could hide malicious code"
            },
            {
                "name": "eval_dynamic_code",
                "pattern": r"eval\s*\(\s*[^)]*\)",
                "confidence": 0.7,
                "description": "Dynamic code execution that could be exploited"
            },
            {
                "name": "hidden_admin_accounts",
                "pattern": r"(admin|root|backdoor|debug)\s*[:=]\s*['\"][^'\"]*['\"]",
                "confidence": 0.5,
                "description": "Potential hidden administrative accounts"
            },
            {
                "name": "obfuscated_strings",
                "pattern": r"['\"][A-Za-z0-9+/=]{100,}['\"]",
                "confidence": 0.4,
                "description": "Heavily obfuscated strings that could hide malicious content"
            }
        ]
    
    def _load_malware_signatures(self) -> List[str]:
        """Load malware signatures"""
        # In production, this would load from actual signature database
        return [
            "rule malware_generic { strings: $a = \"malicious_payload\" condition: $a }",
            "rule backdoor_generic { strings: $a = \"backdoor_trigger\" condition: $a }"
        ]
    
    async def scan_software_package(self, vendor_id: str, software_path: str, 
                                  software_name: str, software_version: str) -> ScanResult:
        """Perform comprehensive scan of software package"""
        scan_id = self._generate_scan_id(vendor_id, software_name)
        start_time = datetime.now()
        
        scan_result = ScanResult(
            scan_id=scan_id,
            vendor_id=vendor_id,
            software_name=software_name,
            software_version=software_version,
            scan_type=ScanType.DEPENDENCY_SCAN,
            vulnerabilities=[],
            backdoor_indicators=[],
            malware_detected=False,
            overall_risk_score=0.0,
            scan_duration=0.0,
            scanned_files=0,
            scan_timestamp=start_time,
            scanner_version="1.0.0"
        )
        
        try:
            # Extract and prepare software for scanning
            extracted_path = await self._extract_software_package(software_path)
            
            # Perform different types of scans
            vulnerabilities = await self._scan_vulnerabilities(extracted_path, software_name, software_version)
            backdoor_indicators = await self._scan_backdoors(extracted_path)
            malware_detected = await self._scan_malware(extracted_path)
            
            # Count scanned files
            scanned_files = self._count_files(extracted_path)
            
            # Aggregate results
            scan_result.vulnerabilities = vulnerabilities
            scan_result.backdoor_indicators = backdoor_indicators
            scan_result.malware_detected = malware_detected
            scan_result.scanned_files = scanned_files
            scan_result.overall_risk_score = self._calculate_risk_score(
                vulnerabilities, backdoor_indicators, malware_detected
            )
            
            # Cleanup
            await self._cleanup_extracted_files(extracted_path)
            
        except Exception as e:
            print(f"Scan failed for {software_name}: {e}")
            scan_result.overall_risk_score = 10.0  # Maximum risk for failed scans
        
        scan_result.scan_duration = (datetime.now() - start_time).total_seconds()
        return scan_result
    
    async def _extract_software_package(self, software_path: str) -> str:
        """Extract software package for analysis"""
        temp_dir = tempfile.mkdtemp(prefix="security_scan_")
        software_file = Path(software_path)
        
        try:
            if software_file.suffix.lower() == '.zip':
                with zipfile.ZipFile(software_path, 'r') as zip_ref:
                    zip_ref.extractall(temp_dir)
            elif software_file.suffix.lower() in ['.tar', '.tar.gz', '.tgz']:
                with tarfile.open(software_path, 'r:*') as tar_ref:
                    tar_ref.extractall(temp_dir)
            else:
                # For single files, copy to temp directory
                import shutil
                shutil.copy2(software_path, temp_dir)
        
        except Exception as e:
            raise Exception(f"Failed to extract software package: {e}")
        
        return temp_dir
    
    async def _scan_vulnerabilities(self, extracted_path: str, software_name: str, 
                                  software_version: str) -> List[Vulnerability]:
        """Scan for known vulnerabilities"""
        vulnerabilities = []
        
        # Update vulnerability database if needed
        await self._update_vulnerability_db()
        
        # Scan dependencies
        dependency_vulns = await self._scan_dependencies(extracted_path, software_name, software_version)
        vulnerabilities.extend(dependency_vulns)
        
        # Scan binary files
        binary_vulns = await self._scan_binaries(extracted_path)
        vulnerabilities.extend(binary_vulns)
        
        # Scan source code
        source_vulns = await self._scan_source_code(extracted_path)
        vulnerabilities.extend(source_vulns)
        
        return vulnerabilities
    
    async def _scan_dependencies(self, extracted_path: str, software_name: str, 
                               software_version: str) -> List[Vulnerability]:
        """Scan software dependencies for vulnerabilities"""
        vulnerabilities = []
        
        # Look for dependency files
        dependency_files = [
            "package.json", "requirements.txt", "pom.xml", "build.gradle",
            "Gemfile", "composer.json", "go.mod", "Cargo.toml"
        ]
        
        for root, dirs, files in Path(extracted_path).rglob("*"):
            for file in files:
                if file in dependency_files:
                    file_path = Path(root) / file
                    deps = await self._parse_dependency_file(file_path)
                    
                    for dep in deps:
                        dep_vulns = await self._check_dependency_vulnerabilities(dep)
                        vulnerabilities.extend(dep_vulns)
        
        return vulnerabilities
    
    async def _parse_dependency_file(self, file_path: Path) -> List[Dict[str, str]]:
        """Parse dependency file to extract dependencies"""
        dependencies = []
        
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            if file_path.name == "package.json":
                import json
                data = json.loads(content)
                deps = data.get("dependencies", {})
                deps.update(data.get("devDependencies", {}))
                
                for name, version in deps.items():
                    dependencies.append({
                        "name": name,
                        "version": version.strip("^~>=<"),
                        "type": "npm"
                    })
            
            elif file_path.name == "requirements.txt":
                for line in content.split('\n'):
                    line = line.strip()
                    if line and not line.startswith('#'):
                        if '==' in line:
                            name, version = line.split('==', 1)
                            dependencies.append({
                                "name": name.strip(),
                                "version": version.strip(),
                                "type": "pip"
                            })
            
            # Add more parsers for other dependency formats as needed
            
        except Exception as e:
            print(f"Failed to parse dependency file {file_path}: {e}")
        
        return dependencies
    
    async def _check_dependency_vulnerabilities(self, dependency: Dict[str, str]) -> List[Vulnerability]:
        """Check dependency for known vulnerabilities"""
        vulnerabilities = []
        
        # Query vulnerability databases
        try:
            # Simulate vulnerability check (in production, query actual databases)
            if "vulnerable" in dependency["name"].lower():
                vulnerabilities.append(Vulnerability(
                    cve_id="CVE-2023-12345",
                    severity=VulnerabilitySeverity.HIGH,
                    score=7.5,
                    description=f"Known vulnerability in {dependency['name']}",
                    affected_component=dependency["name"],
                    version_range=f"<= {dependency['version']}",
                    fix_available=True,
                    fix_version="1.2.3",
                    published_date=datetime.now() - timedelta(days=30),
                    discovered_date=datetime.now()
                ))
        
        except Exception as e:
            print(f"Failed to check vulnerabilities for {dependency['name']}: {e}")
        
        return vulnerabilities
    
    async def _scan_binaries(self, extracted_path: str) -> List[Vulnerability]:
        """Scan binary files for vulnerabilities"""
        vulnerabilities = []
        
        binary_extensions = ['.exe', '.dll', '.so', '.dylib', '.jar', '.war']
        
        for root, dirs, files in Path(extracted_path).rglob("*"):
            for file in files:
                file_path = Path(root) / file
                if file_path.suffix.lower() in binary_extensions:
                    binary_vulns = await self._analyze_binary_file(file_path)
                    vulnerabilities.extend(binary_vulns)
        
        return vulnerabilities
    
    async def _analyze_binary_file(self, file_path: Path) -> List[Vulnerability]:
        """Analyze binary file for vulnerabilities"""
        vulnerabilities = []
        
        try:
            # Check file size
            if file_path.stat().st_size > self.config["max_file_size"]:
                return vulnerabilities
            
            # Perform basic binary analysis
            with open(file_path, 'rb') as f:
                content = f.read(1024)  # Read first 1KB
            
            # Check for suspicious patterns in binary
            if b"backdoor" in content.lower() or b"malware" in content.lower():
                vulnerabilities.append(Vulnerability(
                    cve_id="CUSTOM-BINARY-001",
                    severity=VulnerabilitySeverity.CRITICAL,
                    score=9.0,
                    description="Suspicious strings found in binary file",
                    affected_component=str(file_path),
                    version_range="all",
                    fix_available=False,
                    fix_version=None,
                    published_date=datetime.now(),
                    discovered_date=datetime.now()
                ))
        
        except Exception as e:
            print(f"Failed to analyze binary {file_path}: {e}")
        
        return vulnerabilities
    
    async def _scan_source_code(self, extracted_path: str) -> List[Vulnerability]:
        """Scan source code for vulnerabilities"""
        vulnerabilities = []
        
        source_extensions = ['.py', '.js', '.java', '.c', '.cpp', '.cs', '.php', '.rb', '.go']
        
        for root, dirs, files in Path(extracted_path).rglob("*"):
            for file in files:
                file_path = Path(root) / file
                if file_path.suffix.lower() in source_extensions:
                    source_vulns = await self._analyze_source_file(file_path)
                    vulnerabilities.extend(source_vulns)
        
        return vulnerabilities
    
    async def _analyze_source_file(self, file_path: Path) -> List[Vulnerability]:
        """Analyze source code file for vulnerabilities"""
        vulnerabilities = []
        
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
            
            # Check for common vulnerability patterns
            vuln_patterns = [
                (r"eval\s*\(", "Code injection vulnerability", VulnerabilitySeverity.HIGH),
                (r"exec\s*\(", "Command injection vulnerability", VulnerabilitySeverity.HIGH),
                (r"system\s*\(", "Command injection vulnerability", VulnerabilitySeverity.HIGH),
                (r"SELECT\s+.*\s+FROM\s+.*\s+WHERE\s+.*=\s*['\"]?\$", "SQL injection vulnerability", VulnerabilitySeverity.CRITICAL),
                (r"password\s*=\s*['\"][^'\"]*['\"]", "Hardcoded password", VulnerabilitySeverity.MEDIUM)
            ]
            
            for pattern, description, severity in vuln_patterns:
                matches = re.finditer(pattern, content, re.IGNORECASE)
                for match in matches:
                    vulnerabilities.append(Vulnerability(
                        cve_id=f"CUSTOM-SOURCE-{hash(pattern) % 10000:04d}",
                        severity=severity,
                        score=self._severity_to_score(severity),
                        description=description,
                        affected_component=str(file_path),
                        version_range="all",
                        fix_available=False,
                        fix_version=None,
                        published_date=datetime.now(),
                        discovered_date=datetime.now()
                    ))
        
        except Exception as e:
            print(f"Failed to analyze source file {file_path}: {e}")
        
        return vulnerabilities
    
    async def _scan_backdoors(self, extracted_path: str) -> List[BackdoorIndicator]:
        """Scan for backdoor indicators"""
        indicators = []
        
        if not self.config["backdoor_detection"]["enabled"]:
            return indicators
        
        for root, dirs, files in Path(extracted_path).rglob("*"):
            for file in files:
                file_path = Path(root) / file
                if file_path.is_file():
                    file_indicators = await self._analyze_file_for_backdoors(file_path)
                    indicators.extend(file_indicators)
        
        return indicators
    
    async def _analyze_file_for_backdoors(self, file_path: Path) -> List[BackdoorIndicator]:
        """Analyze file for backdoor indicators"""
        indicators = []
        
        try:
            # Skip binary files for pattern matching
            if file_path.suffix.lower() in ['.exe', '.dll', '.so', '.dylib']:
                return indicators
            
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
            
            lines = content.split('\n')
            
            for pattern_info in self.backdoor_patterns:
                pattern = pattern_info["pattern"]
                confidence = pattern_info["confidence"]
                description = pattern_info["description"]
                
                for line_num, line in enumerate(lines, 1):
                    matches = re.finditer(pattern, line, re.IGNORECASE)
                    for match in matches:
                        if confidence >= self.config["backdoor_detection"]["confidence_threshold"]:
                            indicators.append(BackdoorIndicator(
                                indicator_type=pattern_info["name"],
                                description=description,
                                confidence=confidence,
                                file_path=str(file_path),
                                line_number=line_num,
                                code_snippet=line.strip(),
                                risk_level=self._confidence_to_risk_level(confidence)
                            ))
        
        except Exception as e:
            print(f"Failed to analyze file for backdoors {file_path}: {e}")
        
        return indicators
    
    async def _scan_malware(self, extracted_path: str) -> bool:
        """Scan for malware using signatures"""
        if not self.config["malware_detection"]["enabled"]:
            return False
        
        try:
            # In production, this would use actual malware scanning engines
            # For now, simulate malware detection
            
            for root, dirs, files in Path(extracted_path).rglob("*"):
                for file in files:
                    file_path = Path(root) / file
                    if await self._check_malware_signatures(file_path):
                        return True
            
            return False
        
        except Exception as e:
            print(f"Malware scan failed: {e}")
            return False
    
    async def _check_malware_signatures(self, file_path: Path) -> bool:
        """Check file against malware signatures"""
        try:
            with open(file_path, 'rb') as f:
                content = f.read()
            
            # Simple signature matching (in production, use YARA or similar)
            malicious_patterns = [b"malicious_payload", b"backdoor_trigger", b"virus_signature"]
            
            for pattern in malicious_patterns:
                if pattern in content:
                    return True
            
            return False
        
        except Exception:
            return False
    
    def _count_files(self, extracted_path: str) -> int:
        """Count number of files scanned"""
        count = 0
        for root, dirs, files in Path(extracted_path).rglob("*"):
            count += len(files)
        return count
    
    def _calculate_risk_score(self, vulnerabilities: List[Vulnerability], 
                            backdoor_indicators: List[BackdoorIndicator], 
                            malware_detected: bool) -> float:
        """Calculate overall risk score"""
        score = 0.0
        
        # Vulnerability score contribution
        for vuln in vulnerabilities:
            score += vuln.score * 0.1
        
        # Backdoor indicator contribution
        for indicator in backdoor_indicators:
            score += indicator.confidence * 5.0
        
        # Malware detection contribution
        if malware_detected:
            score += 10.0
        
        return min(score, 10.0)  # Cap at 10.0
    
    def _severity_to_score(self, severity: VulnerabilitySeverity) -> float:
        """Convert severity to numeric score"""
        mapping = {
            VulnerabilitySeverity.CRITICAL: 9.0,
            VulnerabilitySeverity.HIGH: 7.0,
            VulnerabilitySeverity.MEDIUM: 5.0,
            VulnerabilitySeverity.LOW: 3.0,
            VulnerabilitySeverity.INFO: 1.0
        }
        return mapping.get(severity, 5.0)
    
    def _confidence_to_risk_level(self, confidence: float) -> str:
        """Convert confidence to risk level"""
        if confidence >= 0.8:
            return "high"
        elif confidence >= 0.6:
            return "medium"
        else:
            return "low"
    
    async def _update_vulnerability_db(self):
        """Update vulnerability database"""
        if (datetime.now() - self.vulnerability_db["last_updated"]) > self.vulnerability_db["update_interval"]:
            # In production, fetch from actual vulnerability databases
            self.vulnerability_db["last_updated"] = datetime.now()
    
    async def _cleanup_extracted_files(self, extracted_path: str):
        """Clean up extracted files"""
        try:
            import shutil
            shutil.rmtree(extracted_path)
        except Exception as e:
            print(f"Failed to cleanup extracted files: {e}")
    
    def _generate_scan_id(self, vendor_id: str, software_name: str) -> str:
        """Generate unique scan ID"""
        timestamp = datetime.now().isoformat()
        content = f"{vendor_id}_{software_name}_{timestamp}"
        return hashlib.sha256(content.encode()).hexdigest()[:16]
    
    async def generate_scan_report(self, scan_result: ScanResult) -> Dict[str, Any]:
        """Generate comprehensive scan report"""
        return {
            "scan_summary": {
                "scan_id": scan_result.scan_id,
                "vendor_id": scan_result.vendor_id,
                "software_name": scan_result.software_name,
                "software_version": scan_result.software_version,
                "overall_risk_score": scan_result.overall_risk_score,
                "scan_duration": scan_result.scan_duration,
                "scanned_files": scan_result.scanned_files,
                "scan_timestamp": scan_result.scan_timestamp.isoformat()
            },
            "vulnerabilities": [asdict(vuln) for vuln in scan_result.vulnerabilities],
            "backdoor_indicators": [asdict(indicator) for indicator in scan_result.backdoor_indicators],
            "malware_detected": scan_result.malware_detected,
            "recommendations": self._generate_scan_recommendations(scan_result),
            "generated_at": datetime.now().isoformat()
        }
    
    def _generate_scan_recommendations(self, scan_result: ScanResult) -> List[str]:
        """Generate recommendations based on scan results"""
        recommendations = []
        
        if scan_result.vulnerabilities:
            recommendations.append("Update software to latest version to address known vulnerabilities")
            recommendations.append("Implement additional security controls for high-risk vulnerabilities")
        
        if scan_result.backdoor_indicators:
            recommendations.append("Investigate potential backdoor indicators with vendor")
            recommendations.append("Implement additional monitoring for suspicious activities")
        
        if scan_result.malware_detected:
            recommendations.append("CRITICAL: Malware detected - quarantine software immediately")
            recommendations.append("Conduct forensic analysis of infected software")
        
        if scan_result.overall_risk_score > 7.0:
            recommendations.append("Consider alternative vendors due to high security risk")
        
        recommendations.extend([
            "Implement continuous monitoring of vendor software",
            "Establish regular security scanning schedule",
            "Require vendor to provide security attestations"
        ])
        
        return recommendations